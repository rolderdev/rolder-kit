# UseData

Загружает данные нескольких классов по схеме на сервере Kuzzle.

## Возможности

* Умеет выстраивать загрузку данных в очередь или загружать одновременно.
* Может фильтровать и сотритровать каждый класс БД.
* Подписывается на изменения в БД.
* Может осуществлять поиск по разным полям разных классов БД.
* Может проставлять связи между классами БД.
* Пагинация.
* Может загружать историю изменений данных.
* Может загружать иерархию данных.
* Может возвращать ошибки с сервера.

## Ограничения

* 1000 документов для одного класса БД.

## Порты

### Вход

| Название Noodl | Системное название | Тип данных | Требуется | Зависимость | Комментарий |
| --- | --- | --- | --- | --- | --- |
| Output DB classes | outputDbClasses | proplist | - | - | Назавние класса БД без версии. Каждый класс сформирует несколько выходных портов |
| Scheme | fetchScheme | array | При монтировании | - | Схема |
| Search | searchEnabled | boolean | - | - | Включить поиск |
| Search string | searchString | string | - | searchEnabled | Строка поиска |
| Pagination | paginationEnabled | boolean | - | - | Включить пагинацию |
| Pagination DB class | paginationDbClass | string | При монтировании | paginationEnabled | Класс БД, по которому будет происходить пагинация |
| Next | nextFetch | signal | - | paginationEnabled | Загрузить следующую страницу |
| Previous | previousFetch | signal | - | paginationEnabled | Загрузить предыдущую страницу |
| Кefetch | refetch | signal | - | - | Загрузить повторно |

### Выход

| Название Noodl | Системное название | Тип данных | Комментарий |
| --- | --- | --- | --- |
| Fetching | fetching | boolean | Статус загрузки |
| Fetched | fetched | signal | Сигнал загрузки |
| Data | data | object | Все результаты загрузки |
| \[название класса\]Items | \[название класса\]Items | array | Документы загруженного класса |
| \[название класса\]Fetched | \[название класса\]Fetched | number | Количество загруженных документов класса |
| \[название класса\]Total | \[название класса\]Total | number | Количество всех документов класса в БД |
| \[название класса\]Aggregations | \[название класса\]Aggregations | object | Результат агрегаций |
| Page | fetchedPage | number | Текущая страница пагинации |
| Error | error | boolean | Не удалось загрузить данные |

## Инструкция

### Схема

| Ключ | Тип данных | Дефолтное значение | Комментарий |
| --- | --- | --- | --- |
| dbClass | string | - | Как в Kuzzle, но без версии. Единственный обязательный параметр |
| size | number | 10 | Количество запрашиваемых документов. Может быть от 0 до 1000 |
| order | number | - | Номер для построения очереди загрузки документов |
| filters | object | - | [Фильтры Kuzzle](https://docs.kuzzle.io/core/2/api/koncorde-filters-syntax/clauses/). Этот код выполнится на уровне Noodl, а значит можно использовать переменные, результат выполнения функций, библиотеки |
| filtersFunc | string-function | - | Функция, которая на вход принимает data и должна выдавать фильтры в том же формате, что и filters. Data подается в том же формате, что и на выходной порт, но с данными, которые загрузились в очереди на предыдущих шагах. Этот код выполняется на сервере Kuzzle, соответсвенно не может использовать переменные, функции и библиотеки с Noodl. Для удобства лучше сначала писать функцию, чтобы редактор подсветил ошибки, потом обарачивать в косые ковычки. |
| sorts | array | - | Массив объектов сортировки. Порядок объектов - порядок сортировки. Ключ объета - путь к данным. Значение: 'asc' - по возрастанию, 1,2,3; 'desc' - по убыванию, 3,2,1 |
| refs | string[] | - | Массив классов БД для проставления прямых связей. Прямая связь означает, что в данных класса (dbClass) должен быть объект или массив связываемого класса (ref) с id. Система умеет проставлять связи в любом порядке, не важно какой класс загрузится первым - dbClass или refs. Пример: dbClass - улица, ref - город, тогда каждая улица проставит себе все данные с города, на который ссылается. |
| backRefs | string[] | - | Массив классов БД для проставления обратных связей. Обратная связь означает, что в данных свзяываемого класса (ref) должен быть объект или массив с id dbClass. Связь проставится в dbClass массивом классов из refs. Пример: dbClass - город, ref - улица, тогда каждый город проставит себе все данные улиц, которые ссылаются на этот город. |
| searchFields | string[] | - | Массив путей к данным для поиска. Игнорируется, если не включен параметр searchEnabled. Поиск начинает использовать этот параметр, когда searchString не пустой |
| history | number | - | Включает загрузку истории. Может быть от 1 до 1000. История изменений документа попадет в ключ history. Изменения отсортированы по времени появления документов, по убыванию - последнее изменение будет первым объектом массива |
| aggregation | object | - | Запрос [агрегации данных](https://www.elastic.co/guide/en/elasticsearch/reference/7.17/search-aggregations.html). Можно одновременно загружать данные и делать агрегацию. При этом агрегация не ограничена параметром size. Если нужна только агрегация, нужно выставить size в 0. В таком случае, агрегация будет обрабатываться быстро, т.к. документы не будут загружаться. |

### Примеры

#### Минимальная схема

Загрузит 10 документов класса.

```js
[
    {
        dbClass: 'street'    
    }
]
```

#### Параллельная загрузка

Загрузит 100 документов класса street, и 10 класса city.

```js
[
    {
        dbClass: 'street',
        size: 100
    },
    {
        dbClass: 'city'
    }
]
```

#### Прямые связи

Загрузит одновременно оба класса и проставит city в каждый street.

```js
[
    {
        dbClass: 'street', 
        refs: ['city']
    },
    {
        dbClass: 'city'
    }
]
```

#### Обратные связи

Загрузит одновременно оба класса и проставит массив street в каждый city.

```js
[
    {
        dbClass: 'street'
    },
    {
        dbClass: 'city',
        backRefs: ['street']
    }
]
```

#### Сортировка

Загрузит street и отсоритрует их по названию по возрастанию.

```js
[
    {
        dbClass: 'street',
        sorts: [{'content.name': 'asc'}]
    }
]
```

#### Сортировка

Отсоритрует street по количесву домов по убыванию и по названию по возрастанию.

```js
[
    {
        dbClass: 'street',
        sorts: [{'content.houseCount': 'desc'}, {'content.name': 'asc'}]
    }
]
```

#### Фильтры

Загрузит street с определенным id city.

```js
[
    {
        dbClass: 'street',
        filters: {
            equals: {'city.id': "some id"}
        }
    }
]
```

#### Последовательная загрузка

Сначала загружает country с наcелением больше 100 000 000, потом города этих стран, отфильтровывая city с населением меньше 100 000.

```js
[
    {
        dbClass: 'country',
        order: 0,
        filters: {
            gte: {'content.population': 100000000}
        }
    },
    {
        dbClass: 'city',
        order: 1,
        filters: {
            gte: {'content.population': 100000}
        },
        filtersFunc: = `(data) => { // функция добавит filters, заданный выше к результату
            if (data['country']?.items?.length) { // важно к data обращаться через ['dbClass']
                return { in: { 'country.id': data['country'].items.map(i => i.id) } }
            }
        }`
    }
]
```

#### История изменений

Загрузит из истории изменений последние 10 документов и положит их в ключ history в каждый street.

```js
[
    {
        dbClass: 'street',
        history: 10
    }
]
```

#### Агрегация

Посчитает количество улиц по городам.

```js
[
    {
        dbClass: 'street',
        size: 0,
        aggregations: {
            streetsByCity: { // произвольное название агрегации, может быть несколько
                terms: { field: 'city.id', size: 10000 } // будет считать до 10 000 документво
            }
        }
    }
]
```

#### Агрегация в агрегации

Посчитает количество улиц по городам и для каждой агрегации по городам суммирует количество домов.

```js
[
    {
        dbClass: 'street',
        size: 0,
        aggregations: {
            streetsByCity: {
                terms: { field: 'city.id', size: 10000 },
                aggs: { // вложеная агрегация
                    housesSumByCity: {sum: { "field": "houseCount" } }
                }
            }
        }
    }
]
```

#### Иерархия

Функция для построения иерархии принимает 3 параметра:
* parentItem - item, который запрашивает для себя детей.
* level - текущий уровень, начиная с 0.
* data - вся data на момент запроса.

Функция должна вернуть новую схему. Эта схема будет запускаться пока не закончатся дети, но не больше 10 уровней.
К возвращаемой схеме применяются все теже требования, что и к основной.

Пример скачает всю иерархию класса group:

```js
[
    {
        dbClass: 'group',
        filters: { not: { exists: 'group.id' } },
        sorts: [{ 'content.name': 'asc' }],         
        hierarchyFunc: `(level, parentItem, parentData) => {
            if (level === 5) return // отменяем по какой-то логике
            else return [ // возвращаем схему, которая скачает нужные данные для каждого родителя
                {
                    dbClass: 'group',
                    filters: { equals: { 'group.id': parentItem.id } }, // фильтр, который выдает только детей
                    sorts: [{ 'content.name': 'asc' }],
                    filtersEvalFunc: (localData, parentIem, parentData) => { // Обрати внимение на название. Посколькоу все это уже обернуто в текст, 
                                                // нам нужно сказать серверу, что не нужно пытаться это делать снова. 
                                                // Для этого исползуем filtersEvalFunc вместо filtersFunc.
                                                // Такое же правило и для hierarchyFunc, если нужно запустить иерархию внутри иерархии
                        return { not: { equals: { 'states.archived': true } } }
                    }                    
                }
            ]
        }`
    }
]
```

## Конфигуратор

import UseData from '../../src/wrappers/data/useData'

<UseData />

## История изменений

### v1.3.0 `2024.04.08`

:::warning #pre-release
:::

:::warning Требует обновления сервера
:::
 
* Добавлена возможность скачивать иерархию. Ограничения: не работает поиск по иерахии.
* Функции научились возвращать ошибки.
* Версионность классов БД переехала на сервер.
* Теперь каждый item выдает в своей структуре dbClass.
* Добавлен выходной порт Error. Становится true при ошибках.
* Исправлена ошибка, когда данные по каким то причинам не загружались, статус Fetching оставлася true.

### v1.2.0 `2024.04.01`

:::warning #pre-release
:::

* Добавлена документация.
* `#breakingChange` Добавлена проверка максимального количества загружаемых документов.
* Добавлена история изменения данных. Требуется обновить сервер.
* Исправлен баг - сигнал refetch выдавал старые данные.../../../src/wrappers/data/useData
* `#breakingChange` По завершению загрузки все данные в порты выдаются одновременно, после срабатывает сигнал fetched.../../src/wrappers/data/useData