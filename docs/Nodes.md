# Принцип интеграции Rolder Kit в Noodl
## Код нужно смотреть в этом репозитарии по пути: src/main, где:
* getNodes - набор функций для интеграции в Noodl
* nodes - импорты нод
* ports - схемы портов
## Общие принципы для JS-нод и React-нод
* Все ноды импортируются разом. На уровне Noodl это один модуль, который регистрируется в главном файле всего Rolder Kit - main.ts
## Процесс регистрации ноды в Noodl
1. Noodl ищет в папке noodl_modules папки, у торых есть файл manifest.json. Подпапки не проверяются.
2. Noodl считывает в manifest.json путь к входному фалу модуля. У нас это main.js.
3. Noodl запускает (как именно не известно) main.js. В теле main.js два блока - импорт библиотек и defineModule из noodl-sdk: 
    * Библиотеки используются на уровне Noodl в функциях (dayjs, например). Каждая библиотека прикрепляется к глобальному объекту window, из-за чего их можно вызывать без префикса.
    * В defineModule заданы JS-ноды, React-ноды и порты на уровне проекта Noodl. JS-ноды и React-ноды подаются через импорт фалйов, в которых, в свою очередь, перечислены импорты каждой ноды. Происходит внутренняя магия Noodl. Очень ждем открытия кода Noodl :)
4. Разарботчик вставляет ноду в проект. С этого момента запускается defineReactNode из noodl-sdk для React-ноды и defineNode для JS-ноды. Оба метода работают одинаково, за тем исключением, что для React-ноды запускается дополнительный метод getReactComponent, в который передается React-компонента. 
5. Дальше можно условно разделить на несколько этапов работу ноды:
    1. Регистрируются все методы: getReactComponent, inputs (в нашем случае задается один - version), setup, initialize, methods, changed. Есть другие, мы их не используем: signals, outputs, inputProps, outputProps и кто его знает какие еще.
    2. setup. Здесь происходит первичная настройка ноды. Запускается разово при вставке ноды.
    3. initialize. Здесь обычно задают переменные. Запускается каждый раз при обновлении экрана Noodl.
    4. methods. Сюда можно добавлять свои методы, чтобы вызывать их в других местах. Есть встроенные методы, для нас важны registerInputIfNeeded и registerOutputIfNeeded (подробнее в описании процесс регистрации портов).
### Порты
#### Принципы работы портов
* Порт в Noodl - слоенный пирог. На уровне Noodl это порт в интерфейсе. Уровнем ниже это порт ноды. Если это React-нода, то еще уровнем ниже это props React-компоненты.
* Схема порта:
    ```ts
    export type NodePort = {
        plug?: 'input' | 'output' // входящий или исходящий
        type: Type // тип данных порта. Поддерживает такие примитывы: string, number, boolean. Поддерживает массивы и объекты. Кроме стандартных типов данных есть несколько нудловских, мы используем такие: signal, enum (список для выбора, можно добавлять units: ['px', '%', 'rem']), proplist (ручное добавление текстовых значений в массив, удобно, когда нужно перечилсть зараннее не известные константы).
        name: string // системное название
        displayName: string // название, которое видно в интерфейсе ноды
        group: string // для группировки в интерфейсе ноды
        default?: any // дефолтное значение. Используется только для примитивов.
        tooltip?: string // всплывающая подсказка в интерфейсе ноды
        required?: boolean // требуется заполнить. Выдает предупреждение в интерфейсе ноды. * Наша расширение возможностей Noodl. 
        dependsOn?: { name: string, value: boolean | string } // Зависит от другого порта. Порт исчезает, если значение зависимого порта не совпадает. Так можно менять целые списки портов в зависимоости от выбора одного порта. На основе этого работает версионность. * Наша расширение возможностей Noodl. 
        isObject?: boolean // Появилась и-за того, что в интерфейсе ноды нелзья редактировать объект. Поэтому подается массив с одним объектом, если этот параметр задан, то происходит конвертация. * Наша расширение возможностей Noodl. 
    }
    ```
* Проверяются на пустое значение, если задано required. При этом false, не является пустым значением.
* Проверяется формат данных. Работают проверки примитивов, массивов и объектов. При этом происходит проверка только типа данных, внтурення структура не проверяется. Если для массива в параметрах порта задано isObject, такое тип так же будет проверен.
#### Процесс регистрации и проверки портов для React-ноды
1. При вставке ноды регистрируется один input - version. При дальнейшем использовании, значение версии применяется в дальнейших этапах. Пока версия не выбрана, нода пустая, код буквально не вставлен в ноду. Такой подход позволяет строкго разделить версионность.
2. getReactComponent. Этап регистрация React компоненты.
```ts
    getReactComponent() {
      return forwardRef(CompsHandler)// forwardRef - нужен для передачи сигналов с уровня Noodl на уровень React. CompsHandler - React-функция-компонента, получает результат от ноды и в зависомсти от них рисует компоненту выбранной версии. Передает пустую React-компонент, если условия не выполнены. Так исключаются ошибки на уровне React пока не закрыты требования к портам.
    },
```
3. setup. Этап регистрирует порты на уровне Noodl при добавлении ноды или изменении версии:
    ```ts
    setup: function (context: any, graphModel: any) {
        if (!context.editorConnection || !context.editorConnection.isRunningLocally()) { return } // ничего не делаем, если нода запущена не в редакторе Noodl.
        graphModel.on(`nodeAdded.rolder-kit.${nodeName}_${nodeVersion}`, function (node: any) { // событие, когда нода вставлена на уровне Noodl
            context.editorConnection.sendDynamicPorts(node.id, getNodePorts(node, compVersions)) // определяем порты в зависимости от выбранной версии
            node.on('parameterUpdated', function () { context.editorConnection.sendDynamicPorts(node.id, getNodePorts(node, compVersions)) }) // устанавливаем триггер, для последующего обновления портов при изменении любого из них.
        });
    }
    ```
4. initialize. Этап для переменных:
    ```ts
    initialize: function () {      
        this.props.node = this // передача ноды в компоненту. В компоненте отсюда будут браться resultInputs
        this.nodeInited = false // статус для урпавления первичной загрузкой. Нужен для React-компоненты, которая должна рендериться при каждом изменении порта, но не должна этого делать при первичной загрузке. Иначе получается сколько портов, столько и лишних рендерингов.        
        this.resultInputs = {} // обработанные и проверенные данные инпутов
        this.warnings = { count: 0, requiered: {}, types: {} } // счетчик предупреждений и объекты с портами не прошедших проверку на "требуется" или "не тот тип данных"        
    },
    ```
5. methods. Этап регистрации методов:
    * registerInputIfNeeded. Регистрирует инпуты и передает их данный в метод setInputsValue (отдельный этап).
    ```ts
    registerInputIfNeeded: function (name: any) { // запускается для каждого инпута, если тот есть на уровне Noodl и в нем есть не дефолтные данные
        if (this.hasInput(name)) return // не регистрируем инпут, если он уже есть
        this.registerInput(name, {
          set: function (value: any) { // встроенный метод для передачи данных инпута
            this.setInputsValue(name, value) // наш метод, ниже его описание
            // Signals definition this input and is true, means signal triggered
            if (compVersions[this._inputValues.version]?.signals?.map(i => i.name).includes(name)) { // если сигнал и его значение true. Здесь раскрыта тайна сигналов на уровне Noodl. На уровне JS, даже не React, нет никаких сигналов, есть только методы, функции. Поэтому Noodl внутри сиганла передает простое значение true и сразу за ним false. Так и получается сигнал, мгновенное преключение true/false. 
              this.innerReactComponentRef?.[name](); // запуск метода на уровне React. Метод задается каждый раз по разному, но всегда вызывает функцию внутри React-компоненты, которая уже и делает работу.
            }
          }
        });
      },   
    ```
    * registerOutputIfNeeded. Регистрирует аутпуты и передает данные на уровень Noodl.
    ```ts
     registerOutputIfNeeded: function (name: any) {
      if (this.hasOutput(name)) return
        this.registerOutput(name, { get() { return this.outputPropValues[name] }, }); // метод, который запускается из React компоненты. Сначала передаем значение в outputPropValues, потом запускаем flagOutputDirty, который запускает get() и передает данные на уровень Noodl. Для выходящих сигналов get() не используется, но регистрация нужна. Сигнал подается внутри компоненты методом sendSignalOnOutput.
     },
    ```
6. changed. Срабатывает на изменения данных в инпуте. В том числе и при первичном загрузке. У нас статично только один инпут - версия. Поскольку этот метод срабатывает всегда при закгрузке и изменении версии, он используется для передачи дефолтных значений. Кроме того, здесь фиксируется, что нода загрузилась первый раз.
    ```ts
    changed: {
      version() {
        this.scheduleAfterInputsHaveUpdated(() => { // метод, который срабатывает, когда все инпуты были обновлены. Так гаранитруется, что проверки будут запущены только после всех обновлений.        
          this.setInputsValue('firstLoad', true) // запускаем метод. За счет scheduleAfterInputsHaveUpdated точно выполнится после первичного исполнения 5-го этапа. На этом этапе устанавливаются все дефолтные значения, если не установлено других. Все не дефолтные значения проверяются на тип данных. Все инпуты проверяются на требования их наличия. Описание ниже.
          this.updateComp() // первый раз запускаем обновление React-компоненты. Описание ниже.
          this.nodeInited = true // фиксируем, что первичная загрузка произошла
        })
      }
    }    
    ```
7. methods. Последний этап, собирающий все в кучу и делающий основную работу:
    * setInputsValue. Основной метод всей работы с инпутами.
    ```ts
    setInputsValue: function (inputName: string, inputValue: any) {
        const nodeInputs = compVersions[this._inputValues.version]?.inputs 
        if (nodeInputs) { // ничего не делаем, если инпуты не заданы
          const node = this as NodeInstance          
          const convertedValue = convertAndCheckType(node, nodeInputs, inputName, inputValue) // самая сложная функция. Конвертирует данные Noodl-формата в пригодные для рвботы в React. Проверяет соответствие типа данных. Результаты проверки выдает предупреждениями в интерфейсе Noodl.          
          this._inputValues[inputName] = convertedValue // любое значение сохраняется в "хранилище". Здесь данные запомняться, даже если менять версию или, если инпут был заполнен и спрятан.          
          setValue(node, nodeInputs, inputName, convertedValue) // устанавливает значения в resultInputs, в том числе восстанавливая их из хранилища.
          setDefaults(node, nodeInputs) // устанавливает дефолтное значение, если оно есть в схеме инпута и шагом ранее не было задано. Делает это как для заданного инпута этого метода, так и для зависимых.
          checkRequired(node, nodeInputs) // проверяет инпут поданный в этот метод и зависящие от него инпуты на то, требуются они или нет. Если да, ругается на уровне Noodl.          
          if (this.nodeInited) this.updateComp() // обновляет React-компоненту, если это не первичная загрузка
        }
      },
    ```
    * updateComp. Метод для обновления React-компоненты.
    ```ts
    updateComp: function () {
        if (this.warnings.count === 0) this.compReady = true // если нет пердупреждений, фиксируем готовность. На уровне React-компоненты задано условие, если нет готовности рисует "пустоту" в таком виде: <></>. Иными словами, даже если нода ругается в Noodl, компонента все равно присутствует, но поскольку в нее ничего не передается и ничего не отрисовывается (может пустой div) то ошибки исключены.
        else this.compReady = false
        this.innerReactComponentRef.forceUpdate() // React-компонента не обновится сама, т.к. мы не трогаем ее нативные props. В Mantine есть специальная хука для форсирования обновления, используем ее.
    }
    ```

## Разница между JS-нодами и React-нодами
### JS-ноды
* Импортируются ассинхронно. При бандлинге это выделяет эти ноды в отдельные файлы, а их библитеки в один файл. Библиотеки можно увидеть в папке по размеру - самый большой файл, начинающийся с vendors... Все остальные файлы содержат код JS-нод. Их видно по названию и маленькому размеру.
* Исполняется всегда по входящему сигналу. Сама js-функция лежит в теле сигнала.
### React-ноды
* Импортируются синхронно, из-за чего попадает в основной файл при бандлинге - main.js
* Как и полагается React-компоненте, реактивна, берет контекст с родительских компонент и т.д.
* Любое входящее изменение запускает новый render, если в самой компоненте не заложено иначе. 
