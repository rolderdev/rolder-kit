# useData

## Концепция

Главное отличие от прошлых UseData и GetData в использовании `proxy`. Каждый item в рамках одной useData уникален, не может быть 2 item. Но есть представления (прокси) этого item в 2-х метсах - связи и иерархия. Любое изменение прокси меняет сам item и другие прокси.

## Структура данных сервера

Сервер больше на возвращает иерархию (хоть и загружает данные рекурсивно, как и раньше), теперь он возвращает такую структуру:

- **items** - объект, где ключ - id, занчение - сам item. Всегда уникальны. Содержат только то, что есть в БД. Без связей и иерархии.

* **schemes** - объект, где ключ - хеш схемы, обеспечивающий не повторяемость, значение - объект из нескольих ключей:
  - **scheme** - итоговая схема, по которой сервер скачал items. Используется для подписок.
  - **itemIds** - массив id. Испольхуется для построения связи и иерархии. Обеспечивает повторяемость item в иерархии.
  - **parentId** - id родительского item. Есть только у дочерних схем, когда используется иерархия. Испольхуется для построения иерархии.
  - **aggregations** - агрегации.
  - **fetched** - количество загруженных items этой схемой.
  - **total** - количество доступных items для этой схемы.
  - **error** - ошибка этой схемы.

- **error** - общая ошибка uesData.

## Структура данных useData

useData превращает серверные `items` и `schemes` в Map. Прокси обеспечивает `valtio` (те же ребята, что и `zustand`). Главная разница между этим двумя библиотеками - `valtio` использует прокси и позволяет мутировать состояние, `zustand` - не использует прокси и не дает мутировать.

Структура состояния хранилища (`store` в коде):

- **Реактивные props** - те props, что нужно сравнивать при изменении. Например, схема, которую указывает разработчик.
- **schemes** - Map, повторяет `schemes` сервера, но заменяет `itemIds` на прокси из `items`. Используется подписка на изменение схем. При каждом изменении строится иерархия и проставляются связи. Т.к. используются прокси из `items`, любое изменение item тригерит и изменение схем.
- **items** - повторяет `items` сервера, но в виде Map и оборачивает каждый item в прокси. Подписка не используется. Т.е. здесь прокси используется для синхронизации данных между всеми прокси - в связях, в иерархии и в схемах.
- **hierarchy** - иерархия в `d3-hierarchy` формате. Используется как хранилище.
- **subscribes** - Map, где ключ - хеш схемы, значение - roomId, т.е. канала подписки на данные сервера.

## Сценарии

- **Fetch** - запускается по сигналу в контроллируемом режиме и по изменению реактивных инпутов в реактивном режиме. Обновляет данные.
- **Обновление данных** - основная работа. Обработка происходит в таком порядке:
  - Обновление `items`, т.е. пересоздание прокси.
  - Обновление `schemes` с ссылками на прокси в `items`.
  - Запускает проверку подписок. Отписывается от устаревших схем, подписывается к новым. Асинхронно, но без ожидания, т.к. схемы уже готовы, а состояние подписок только подпискам и нужны.
  - Рроставление прямых связей с ссылками на прокси в `items`.
  - Создание иерархии с ссылками на снепшот в `schemes`, но с ссылками на прокси в `items`, уже имеющие связи. Снепшот не дает редактировать схему разработчику.
  - Создание `data` для схем родительского уровня по той же логике ссылок, что и иерархия.
  - Отправляет данные на выход в `Data`. Для каждой родитеской схемы в свои выходы, если разработчик указал их. Отправляет состояние и сигнал загрузки.
  - Отправялет иерархию на выход.
- **Проверка подписок** - добавляет подписки для новых схем (всех, включая дочерние в иерархии) и удаляет подписки на схемы, которых больше нет.
- **Прилетели данные по подписке**. Для добавления и изменения - сортировка. При добавлении, добавляется и в `items`, и в items схемы. Соответственно, при удалении, наоборот. Любое имзенении запускает обновление данных.
- **Прокси item изменен**: - автоматичесик меняется везде, где используется подписка на изменение. Подписка на изменение может быть в 2-х вариантах - item обернут в Roodl-объект (раньше такие изменения срабатывали только при пересоздании Roodl-объекта), внутри кода компоненты используются методы `valtio` (useSnapsot, subscribe).

## Связи

- Связи больше не используют данные схемы. За счет прокси и того, что данные с сервера прилетают разом, их очень легко проставить везде автоматически.
- Прямые связи исключают связи на самих себя, это задача иерархии.
- Больше нет обратных связей. В них нет смысла, т.к. эту функцию теперь закрывает иерархия. Кроме того, обратные связи порождают бесконечную рекурсию связей, т.к. прямая связь есть всегда. Раньше нельзя было одновременно проставить прямую и обратную связь в рамках двух классов. Теперь можно, но это пораждает бесконечную рекурсию. Прокси на эту рекурсию все равно, это работает, но не удобно из-за того, что Roodl не умеет показывать такие рекурсии в редакторе. Оставил готовый код, на всякий.
