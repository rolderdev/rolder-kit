# Как создать проект на базе шаблона и Rolder Kit
* Скачиваем с этого репозитария из папки dist актуальную версию шаблона и Rolder Kit.
* Распаковываем шаблон, в папку noodl_nodes добавляем распакованный Rolder kit.
* Импортируем проект в Noodl.

# Как обновлять Rolder Kit
* Скачиваем с этого репозитария из папки dist актуальную версию (пароль - 123).
* В Noodl в настройках открываем папку проекта и копируетм Rolder Kit в папку noodl_modules.
* Переносим старую версию Rolder Kit из noodl_modules на всякий случвй. Не должно быть две версии. Что то работать будет, но запутаетесь легко.
* Перезаходим в проект, проверяем не ругается ли Noodl на какую то ноду.

# Структура Rolder Kit
* dist: архивы бандлов для скачивания и добавления в Noodl
* src: исходный код
    * utils: функции-помогайки. Сейчас там набор фнкций для обработки данных: конвертация версии класса БД, вытягивание данных из объекта по шаблону и т.д.
    * libs: фнкции-обертки для сторонних библиотек. Например, errorHandler простая обертка для Mantine notification. Или useData, в которой прописаны все методы для ноды UseData и фабрика генерации запросов keys: то самое главное, что дает нам простоту работы с данными в Rolder Kit.
    * types: типы Typescript.
    * jsNodes: "серые" ноды Noodl или "ноды-действия". Это не React ноды, а ноды Typescript. Сейчас используется простой принцип: одна нода = один сигнал запускащий ее. Примеры: notification для отправки всплывающих сообщений, все ноды в папке data для создания/изменения/удаления данных.
    * rNodes: "синие" ноды Noodl. Это только React-ноды. Могут находиться только в структуре странницы. Могут иметь или не иметь дочерние React-ноды. Не могут принимать сигналы, для этого исползуется инпуты boolean, которые конвертируются внутри ноды в сигнал.
    * main: основной модуль, который загружает весь Rolder-kit. Состоит из функции ports для определения inputs/outputs, nodes для импорта всех нод на уровне js и функции getNodes для подготовки самих нод для Noodl. С верcии Rolder Kit 0.2.0 удалось устроить так, что jsNodes и rNodes выглядят так, как если бы мы их просто создавали для классической разработки, а main уже делает всю магию по превращению их в ноду Noodl.

# Changelog
## 2023-09-06 v0.10.0
### Общие изменения:
* Добавлена функция, которая проверяет есть ли у ноды выход.
* Прикручены контексты React. Для нас это означает, что теперь можно передавать данные в иерархии React-нод от родителей к детям без свзяей на уровне Noodl. Первый пример, это Form и ее дети - TextInput, MaskedInput. Теперь не жуно каждому инпуту передавать formHook.
* Вернулся тип инпута array, снова можно выставлять схемы в праметрах или передавать их снаружи ноды.
* Добавлен новый тип инпута propList. Позволяет задать произвольный список текстовых параметров.
* Добавлена проверка типа данных для нод нового формата.
### Новые ноды:
#### MaskedInput v0(.1.0)
* Инпут, умеющий обрабатывать вводимый текст по маске. Основан на библиотеке: IMask - https://imask.js.org
* Placeholder появляется только при включенном Hide mask.
* Поле mask задает фомратированеи в инпуте. Пример и дефолное значение: {8} (000) 000-00-00. При наборе в инпуте, нули заменяются на значения.
* Не требует formHook для использования формы.
#### Divider v0(.1.0)
* Полоса-разделитель. Можно вставлять label, распологать горизонтально или вертикально, задавать толщину.
#### Title v0(.1.0)
* Текст-заголовок. Один параметр - order. Номер в order прверащает Title в html h1, h2... h6.
### Изменения нод:
#### TextInput v0(.3.0)
* Нода переведена на новыфй формат.
* Поправлен баг, из-за которого нода подхватывала данные из формы со второго раза.
* Больше не требует formHook для использования формы.
* Поправлен баг, из-за которого курсор съезжал в конец строки.
* Поправлен баг, из-за которого при сбросе нода дважды выдавала пустую строку.
#### Table v1(.0.2)
* Добавлен новый формат данных 'mask'. Формат маски задается в 'maskFormat'.
* Возвращены сигналы сброса выбранных объектов.
* Параметр wrap вместо respectLineBreak.
* Добавлен параметр для отмены выбора по нажатию на строку при влюченном singleSelect.
* Добавлена возможность добавлять actions в сгруппированную ячейку первой колонки.
* Добавлен параметр выхода actionItem для различения выбранного обекта при singleSelect и action.
* Добавлен параметр для разворачивания всех групп - expandAll.
* Добавлен параметр multiselect в объекте схемы группировок. Если включен multiselect в настройках таблицы и добавлен multiselect в схему группы, то в сгруппированной строке в первой ячейке добавится чекбокс. По его нажатию, выбираются все дети.
* При группироввке таблица сама выставляет отступы в зависимости от включенных checkbox.
* Поправлен баг, из-за которого нода вылетала, если к выходу Selected items ничего не подключено.
* Поправлен баг, из-за которого нода не выдавала предупреждения об обязательных полях.
* Поправлен баг, из-за которого нода вылетала при первом выборе версии.
* Поправлен баг, из-за опечатки в схеме группировок. Было "groupShceme", исправлено на "groupScheme".
* BFR.
#### Button v0(.2.0)
* Нода переведена на новыфй формат.
* Добавлен stroke к настройкам иконки.
* Нода теперь ругается, а не вылетает, если указана не существующая в Rolder kit иконка.
#### Form v0(.2.0)
* Добавлен параметр validateInputOnChange. Позволяет перечислить поля, которые должны проверяться сразу при печати. Задается в схеме формы. В значении должен быть массив названий полей, совпадающий с названиями в initialValues. Если в параметр передать true, будет проверять все поля.
* formHook теперь пердается внутри Rolder kit, связи больше не нужны.
#### Drawer v0(.3.0)
* Добавлено управление заголовоком. Можно указывать заголовок, размер шрифта, отключать кнопку закрытия.
* Сигнал на выход переименован с hided на closed.
#### UseSearch v1(.0.0)
* Нода переведена на новыфй формат.
* Параметры теперь задаются в более удобном виде.
* BFR.
#### Text v1(.0.0)
* Нода переведена на новыфй формат.
* Добавлена возможность отображать данные по маске.
* Добавлена проверка типа данных.

### Новые утилиты:
#### consoleLog v0(.1.0)
* Внтурення утилита для отправки в консоль сообщений, если в строке браузера debug > 0.
#### IsEmpty
* Утилита, проверяющая любой тип данный на пустоту. Взята из набора утилит 'Just'. Добавлена как глобальная функция: IsEmpty(someVarToCheck)

## 2023-08-31 v0.9.0
### Общие изменения:
* Ноды теперь ругаются на не заполненные праметры не только при выборе версии, но и после обновления. Таким образом, теперь будет наглядно.
* При отсутсвии требуемых праметров React-компонента ноды не будет отресовываться, тем самым не выдавая 'белый экран'.
### Изменения нод:
#### Table v1(.0.1)
* Эта версия заменяет пердыдущую, т.к. в старой обнаружились баги, которые не давали таблице работать совсем.
* Поправлен баг, из-за которого нода не работала при добавлении.
* Поправлен баг, из-за которого нода вылетала при фильтрации.
* Поправлен баг, из-за которого действия не отображались в ячейке, если нет группировок.
#### Drawer v0(.2.0)
* Нода переведена на новыфй формат.
* Добавлены сигналы open() и close().
#### Form v0(.2.0)
* Нода переведена на новыфй формат.
* Удалось изменить способ задания схемы так, чтобы она работала как в документации Mantine. Конкретно в этой части - https://mantine.dev/form/validators/
* Таким образом, схема форм теперь задается ровно так же. Все что нужно, это подтянуть функции-валидаторы. Вот выдуманный пример, где первая строчка показывает как импортировать функции-валидаторы. В остальном как в документации Mantine:
    ```js
    const { hasLength, isNotEmpty, isEmail, matches } = FormValidators

    const formScheme = {
        initialValues: {
            name: '',
            job: '',
            email: '',
            favoriteColor: '',
            age: 18,
        },

        validate: {
            name: hasLength({ min: 2, max: 10 }, 'Name must be 2-10 characters long'),
            job: isNotEmpty('Enter your current job'),
            email: isEmail('Invalid email'),
            favoriteColor: matches(/^#([0-9a-f]{3}){1,2}$/, 'Enter a valid hex color'),
            age: isInRange({ min: 18, max: 99 }, 'You must be 18-99 years old to register'),
        },
    }
    ```

## 2023-08-30 v0.8.0
### Общие изменения:
* Добавлен шаблон проекта. Находится в папке dist. Выше добавлено поисание как использовать.
* Добавлена группа настроек приложения 'Defaults' и первый параметр в ней 'DateFormat'. Постепенно, все ноды, которые форматируют дату внтури (пока только Table) будут форматировать ее по заданному формату из настроек ноды, если не задано, то из Defaults-настроек приложения.
* Изменен прицип работы с цветами. Теперь его нужно указывать текстом как описано в документации Mantine. Пример: 'red.5', где число - shade от 0 до 9. 0 - совсем блеклый, 9 - темный. Можно указать просто цвет, тогда shade будет равен 6. Пока только в Table v1.0.0
* `Большое изменение в принципе разработки нод`. Теперь параметры нод можно назначать динамически. Это решило ряд проблем, добавило плюшек, но внесло и свои ограничения:
    * Версионность. Ноды как и раньше будут называться с первой цифрой версии. Но теперь нужно выбирать в параметрах ноды версию, после чего появятся все настройки этой версии. Выбранный параметр версии сохраняется в Noodl, поэтому при апгрейде ноды все старые версии будут работать. Пока версия не выбрана, нода не отрисовывает React-компоненту.
    * Обязательные параметры. Теперь ноды будут ругаться в самом Noodl, если не хватает каких-то обязательных параметров.
    * Зависымые параметры. Как и раньше по некоторым галочкам будут появляться/исчезать параметры. Но теперь данные у исчезнувших параметров не будут передоваться в ноду, что исключит не понятное поведение. При этом вбитые руками параметры будут сохраняться на уровне Noodl.
    * Сигналы для React-нод. Теперь можно отправлять нормальные сигналы в React-ноды.
    * Все это доступно для Table v1. По мере багфикосв, доработок, переедут и остальные ноды.
    * Ограничения:
        * При обновлении сбрасываются предупреждения.
        * Иногда при смене версии не все поля показываются, нужно обновиться.
        * Группы могут менять свое расположение на панели, если параметр влияет на отображение других параметров.
        * Пришлось отказаться от праметра 'Array', через который задавались схемы. Теперь нужно подавать такие параметры снаружи, через функцию, например.
### Изменения утилит:
#### FilterBy v0(.2.0)
* На входе все фнкции FilterBy теперь ждут объект вместо списка параметров. Так нагляднее.
* Добавлена новая функция FilterBy.reference
    * В отличии от FilterBy.values и FilterBy.dateRange, эта функция не ждет объектов 'items', а сама находит их в Noodl-объектах.
    * На входе ждет объект { dbClass: string, refDbClass: string, reversedRef: boolean }, где:
        * dbClass: название фильтруемого класса
        * refDbClass: название класса, которым фильтруем
        * reversedRef: указывает прямая ли связь или обратная
    * На выходе выдает отфилтрованные объекты заданного класса.
    * Примеры:
        * Есть дома и уборки в них. В каждой уборке указан дом. Скажем из списка выбрано пару домов. Нужно вывести только уборки этих домов. Это прямая связь, фильтруем уборки по домам:
            ```
            const filteredTasks = FilterBy.reference({ dbClass: 'task', refDbClass: 'house' })
            ```
        * Есть дома и уборки в них. В каждой уборке указан дом. Скажем уборки уже отфильтрованы по статусу. Нужно показывать дома только этих уборок. Это обратная связь, фильтруем дома по уборкам:
            ```
            const filteredHouses = FilterBy.reference({ dbClass: 'house', refDbClass: 'task', reversedRef: true })
            ```
### Изменения нод:
#### Table v1(.0.0)
* Смена библиотеки с `Mantine DataTable` на `Mantine React Table`. Ссылка на новую библотеку: https://www.mantine-react-table.com/
* Старая румынская была простая, симпотичная из коробки, но малофункциональная и с парой критичных глюков. Новая американская основана на https://tanstack.com/table/v8, которая считается одной из самых мощных, а главное она headless (нет стилей). Поэтому ее часто прикручивают к UI библиотекам, таким как Mantine или MUI. Она ощутимо сложнее, но может очень много. Для нас важно, что она умеет из коробки делать группировки.
* ETable уйдет в прошлое.
* Как работать с новой нодой:
    * Как и в старой нужно подать схему колонок. Формат старый: массив объектов, где ключ объекта - название праметра, значение - значение параметра.
    * Так выглядит тип данных в коде:
        ```ts
        export interface Column extends MRT_ColumnDef<Item> {
            id: string
            accessor?: string
            groupShceme?: {
                groupBy: string
                accessor: string
                cellProps?: {
                    multiselect?: boolean
                    ml?: number
                }
            }[],
            dataType?: string
            dateFormat?: string,
            cellProps?: {
                ml?: number
            }
            filterProps?: {
                dateFormat: string
            }
            actions: Action[]
        }
        ```
        Из кода видно, что Column расширяет тип MRT_ColumnDef. Это означает, что мы изменяем заданный формат библиотеки. В библиотеке сделано так, что нужно укзывать функцию, чтобы что-то сдлеать с данными, например, отформотировать дату. Мы это убираем и делаем это на уровне Rolder Kit, чтобы разработчику упростить задачу. Таким образом, мы никогда не укзываем в схеме колонок accessorKey или accessorFn как описано в документации. Вместо этого мы указываем просто accessor, а нода сама превратит это в функции и в зависимости от праметров преобразует данные.
    * Схема колонок:
        * Минимально нужно указать accessor и header. По прежнему можно оборачивать accessor в тройные фигурные скобки для экранирования спецсимволов: '{{{path.to.deep.nested.field}}}' или в двойные, когда нужно отформатировать данные по шаблону: '{{path.to.firstField}} бла-бла {{path.to.secondField}}'.        
        * Для форматирования данных нужно указать dataType и параметры этого типа данных. Пока поддерживается только дата. Для даты можно не указывать dateFormat, если устравивает установленный дефолтный параметр в настройках приложения.
    * Группировки.
        * Для включения группировок нужно включить праметр Grouped и в первом объекте схемы добавить параметр groupShceme с массивом, в котором каждый объект состоит из:
            * groupBy: путь к полю, по которому нужно группировать. Обычно это id вложенных объектов по связям.
            * accessor: путь к ключу, данные по которму будут отображаться в первом столбике.
        * Порядок объектов в массиве groupShceme задает порядок группировки.
        * Соответсвенно, если нам нужна группировка по объектам другого класса, то такие объекты должны быть вложены. Иначе группировка произойдет (если по id), но не будут отображаться данные в сгруппированных строках таблицы.
        * Пример схемы:
            ```js
            [
                {
                    accessor: 'content.name',
                    header: 'ЖК > Объект > Уборка',
                    size: 400,
                    cellProps: {
                        // ml: 24
                    },
                    groupShceme: [
                        {
                            groupBy: 'complex.id',
                            accessor: 'complex.content.name',
                            /* cellProps: {
                                multiselect: true
                            } */
                        },
                        {
                            groupBy: 'house.id',
                            accessor: 'house.content.name',
                            /* cellProps: {
                                ml: 42
                            } */
                        }
                    ],
                    actions: [
                        {
                            name: 'editTask',
                            type: 'ActionIcon',
                            props: {
                                actionIcon: {
                                    variant: 'outline',
                                    color: 'dark'
                                },
                                icon: {
                                    iconName: 'IconEdit',
                                }
                            }
                        }
                    ],
                },
                {
                    accessor: 'area.content.name',
                    header: 'Зона',
                    enableColumnFilter: true,
                    filterVariant: 'multi-select',
                },
                {
                    accessor: '{{worker.content.firstName}} {{worker.content.lastName}}',
                    header: 'Сотрудник',
                    enableColumnFilter: true,
                    filterVariant: 'multi-select',
                },
                {
                    accessor: 'content.schedule.startDate.plan',
                    header: 'Дата',
                    dataType: 'date',
                    size: 160,
                    enableColumnFilter: true,
                    filterVariant: 'date-range',
                    filterProps: { dateFormat: 'YYYY-MM-DD' }
                },
                {
                    header: 'Фото',
                    actions: [
                        {
                            name: 'viewImage',
                            type: 'ActionIcon',
                            disabledSource: 'content.results.images',
                            props: {
                                actionIcon: {
                                    variant: 'outline',
                                    color: 'dark'
                                },
                                icon: {
                                    iconName: 'IconPhoto',
                                }
                            }
                        }
                    ],
                    size: 0,
                },
                {
                    accessor: 'states.flow.title',
                    header: 'Статус',
                    size: 140,
                    enableColumnFilter: true,
                    filterVariant: 'multi-select',
                },
            ]
            ```
            Здесь группируются уборки сначала по домам, а потом по ЖК.
    * Фильтры.
        * Включается фильтр параметром enableColumnFilter в схеме колонок.
        * Тип фильтра можно задать через filterVariant. Можно не указывать фильтр, тогда он будет 'text', что равно поиску по полю с подсветкой результатов. Доступные варианты: https://www.mantine-react-table.com/docs/guides/column-filtering#filter-variants
        * Если у фильтра есть параметр, их можно задать через filterProps. Пока только для 'date-range', параметр форматирования даты.
    * Глобальный поиск. Пока доступен только Server-side поиск. Это означает, что нужно использовать UseSearch. UseSearch еще с прошлой версии сам готовит данные со связями. Поэтому, все что нужно, это сделать функцию, которая подает обычные данные, когда поиск выключен, и поисковые, когда включен. Пример в СмартКлине: Планировщик >> Планирование
    * Ширина столбцов. Тут целая история. Есть какая-то проблема с css, из-за которой нельзя сделать автоматическую ширину одних стоблцов, задав конкретную другим. Проблема имеет место быть только, когда мы растягиваем саму таблицу под все доступное место. Удалсоь создать два режима со своими плюсаии и минусами. Второй на практике не потребовался, пока он не доступен, лежит в запасе:
        * Стандартный. Все столбцы подстраивают свою ширину под содержание. Если задать в схеме параметр size (дефолт - 180), то таблица будет расчитывать ширину на его основе. На приктике получилось, что это минимум, от которого таблица пропорционально увеличивает ширину всех столбцов под ширину всей таблицы. Что важно, в этом режиме содеражание не обрезается.
        * Grid mode. Столбцы не подстраиваются под содержание. Ширина столбцов так же расчитывается от size. Можно установить параметр fixed для полной фиксации ширины, но нельзя это делать для последнего столбца.
    * Действия. В каждую колонку можно добавть действия. Они будут отрисовываться в конце ячейки в заданном порядке в схеме. Работает так:
        * В любую колонку нужно подать список действий. Вот тип данных для них (пример выше в схеме):
        ```ts
        export interface Action {
            name: string
            type: 'ActionIcon'
            disabledSource?: string
            props?: any
        }
        ```            
        Где:           
        * name - название действия. Это же название подается на выход в 'Action name'. Использовать это просто. Создаем ноду States, прописываем в ней статусы, названия которых совпадают с name, параметры не нужны. Связываем 'Action name' со 'state' в ноде 'States'. При нажатии на иконку в ячейке выход изменит свое название, а статус это подхватит. Нода State генерирует сигналы на изменение своего статуса, которые дальше уже используем стандартно. Важно, что 'Action name' сразу после нажатия на иконку действия возвращает 'init'. Поэтому глазами смену статуса не увидеть. Лучше смотреть пример )  СмартКлин: Планировщик >> Планирование
        * type - название React-компоненты для отрисовки действия. Сейчас поддерживается 'ActionIcon'
        * disabledSource - строка к данным, по которым дейстиве будет переходить в отключенное состояние. Формат как у accessor. Нода сама проверит тип данных и есть ли там значение. Если пусто, дейстиве перейдет в отключенное состояние.
        * props - параметры React-компоненты. У каждой компоненты свои. В примере схемы видно, что отдельно задаются параметры для иконки и самой ActionIcon. Параметры нужно смотреть в документации Mantine.
### Новые ноды:
#### Checkbox v0(.1.0)
* Стандартный чекбокс. Основные параметры повторены с Mantine. На выходе выдает статус checked. Пока не умеет принимать свой статус извне вручную или через форму.

## 2023-08-14 v0.7.0
### Обновления библиотек:
* Mnatine: 6.0.17 > 6.0.19
### Изменения нод:
#### Новая нода WebCamera v0(.1.0)
* Показывает видеопоток с камеры.
* Можно делать снимки. Это опционально. Если включить, появляется кнопка для фотогрфирования. Какждое нажатие выдает новое фото.
* Работает только через https, т.е. только после публикации приложения.
#### Новая нода QRScanner v0(.1.0)
* Выдает сигнал, что есть успешное сканирпование и строку с результатом.
* Можно установить параметр максимального количества сканирований в секунду.
* Работает только через https, т.е. только после публикации приложения.

## 2023-08-08 v0.6.1
### Изменения нод:
#### PopoverActionIcon v0(.1.1)
* Добавлена дефолтная иконка, чтобы нода не вываливалась в ошибку.

## 2023-08-08 v0.6.0
### Общие изменения:
* Utils. Внутри Rolder Kit есть простые функции, которые часто нужно использовать, они выделены в отдельную папку. Часть из них есть смысл использовать на уровне Noodl. Добавил одну такую утилитку: FilterBy. Это объект, ключами которого сделаны функции. Пока их две: values и dateRange. Возвращает объект с двумя ключами: r - true, если что-то отфильтровалось и i - сами отфильтрованные объекты. Такие утлилиты сидят в объекте window, а значит их можно вызывать напрямую. Поэтому называются с большой буквы, чтобы не путать с локальными функциями.
    * FilterBy.values(items: any[], values: string[], field: string). Фильтрует поданные объекты по списку значений, чаще всего это id. Field умеет принимать dot notation.
    * FilterBy.dateRange(items: any[], dateRange: [Date, Date], field: string). Фильтрует поданные объекты по дате, попадающий в диапазон двух дат. Первая дата округляется на начало дня, вторая на конец. Поле даты в items может быть в любом формате: Date, Dayjs, string.
### Новые ноды:
* Новая молекула PopoverActionIcon v0(.1.0). Можно вставлять другие ноды. Они будут показываться во всплывающем окне при нажатии.
* Новый элемент DatePickerInput v0(.1.0). Позвоялет выбирать дату или период.
* Text v0(.3.0). Теперь можно выставлять ширину.
* ActionIcon v0(.2.0). Теперь умеет принимать статус loading и отображать на иконке loader.
* Table v0(.3.0). Переделан принцип работы с выбороб строк. Есть два вариант, теперь их можно включать оба одновременно:
    * Single row selectable: вариант выбора одной строки при нажатии на любое место в ней. Здесь есть дополнительные параметры. На выходе срабатывает сигнал selected и подается выбранный item: Selected item
    * Multiple row selectable: вариант выбора нескольких строк чекбоксами. На выходе нет сигнала, подаются выбранные item: Selected items.
* SegmentedControl v0(.2.0). Переведен к стандарту инпутов, заданному в Select v0.3.0

## 2023-08-05 v0.5.0
### Изменения нод:
#### App 0.3.0
 * Добавлено обновлние JWT после восстановления потеряной связи и автоматический выход для случая, когда пользователь смотрит на эркна, а JWT уже не валиден. Иначе бывают ситуации, когда кажется, что работает, а уже нет.
#### UseData 0.2.0
* Добавлен вид запроса Custom fetch. Fetch умеет фильтровать по точному совпадению по нескольким полям. Для более сложных запросов пока будем использовать Custom fetch. В query он принимает любой запрос в формте Elasticsearch. Пример, из-за которого возникла потребность. Нужно выдавать данные, у которых статус archived !== true. Такой запрос это решает:
    ```
    [{
        "bool": {
            "must_not": {
                "term": { "states.archived": true }
            }
        }
    }]
    ```

## 2023-08-05 v0.4.0
### Общие изменения:
* Версионность. Теперь про ноды. Наработался опыт изменения версий нод, стало понятно, что не удобно из-за каждого изменения создавать новую ноду в Noodl. Слишком муторно их менять. С другой стороны, нужно как то обезапаситься от ошибок. Берем на вооружение такой принципЖ
    * На уровне Noodl все ноды будут иметь только первую цифру версии, т.е. v0, v1 и т.д.
    * На уровне Rolder Kit, т.е. при его рахработке остаются полные версии из 3-х цифр. Нужно чтобы сохранялась история, чтобы откатиться, если что.
    * Таким образом, версия в Noodlбудет меняться только если есть изменения, которые нельзя совместить с предыдущей версией, которые ломают существующие ноды. Например, если переименован существующий порт, сама нода или изменился формат данных. Переходить будем постепенно. Первая нода: Select v0.
### Изменения нод:
#### Select v0(.4.0)
 * Теперь Select выдает на выход выбранный item. Output называется Selected item.
#### App 0.3.0
 * Исправлен баг, из-за которого новая авторизация выкидвала пользователя раньше положенного.
#### AppShell 0.1.0
 * В схеме параметр color теперь распознается не только для SideBar, но и для Header.

## 2023-08-05 v0.3.0
### Общие изменения:
* Версионность. Разобрался с версионностью. Теперь она приведена к общему подходу. К слову, это так же и для всех проектов, не только Rolder Kit. Принцип верисонирования:
    * Первая цифра: глобальные изменения. Например, переводя Раско на Noodl появится версия 2 как только выдадим клиенту первый набор функций. При этом, начинаем мы с цифры 0, как сейчас со Стартумом, а цифра 1 появится с полным выполнением ТЗ заказчика.
    * Вторая цифра: новые функции, доработки функций.
    * Третья цифра: исправление багов.
    * Соответсвенно, если исправили баги и добавили функйии, растет вторая цифра, если только баги, только последняя.
* В настроки Noodl добавлена версия проекта: Project version. Сейчас просто для удобства, когда Noodl прикрутит Github, будем использовать там. Удобство в том, что при debug=2, версия видна в консоли в объекте Rolder, что помогает не запутаться между вуерсиями dev, stage, prod.
* Уложился принцип использования сторонних библиотек. Все библиотеки называются с большой буквы, чтобы не путать с функциями. Внутри Rolder Kit они импортируются стнадартным способом. В Noodl часть из них подаются в объект window, что позволяет их вызывать напрямую. Сейчас это три библиотеки: Dayjs для работы с датами, Clone для глубоко клонирования объектов и Mustache для работы с шаблонами. Таким образом вызывать их нужно напрямую: Clone(), Dayjs() и т.д.

### Изменения нод:
#### App
* Доработана авторизация. Раньше авторизация обновлялась только с обновлением всей старнницы, сейчас обновляется каждый раз при активации вкладки или всего браузера. Принцип работы:
    * При авторизации Kuzzle возвращает JWT, который записываетсяв куки.
    * При некторых событиях JWT проверяется на актуальность и обновляется. Сравнивается время его жизни (в найстройках Noodl Session timout). Время еще есть, JWT из куки проверяется Kuzzle на валидность. Если JWT валидный и время не вышло, ползователь попадает в приложение, иначе в окно авторизации.
    * Есть три события, когда обрабатывается JWT: при авторизации он первый раз попадает в куки, при нициализации бекенда и активации окна он валидируется и обновляется.
    * Таким образом, если установить Session timout, скажем на 8 часов, то пользователь будет видеть окно авторизации каждое утро, т.к. за ночь JWT ни разу не обновится. Если же поставить на 24 часа, то пользователь будет проходить авторизацию после выходных.

## 2023-08-04 v0.2.0
### Общие изменения:
* Rolder Kit теперь написан на Typescript.
* Все инпуты сгруппированы по типам.

### Новые ноды:
* Новая молекула UnstyledButton. Используется когда какой-то компонент нужно превратить в кнопку. Пример: плитка уборки в Стартуме, в мобильной версии.
* Новая нода для обновления несколько объектов разом: mUpdate.

### Изменения нод:
#### App
* Изменен приницп работы со связями. Теперь свзяи нужно укзывать прямо в схеме классов. Пример:        
    ```
    [
        complex: {
            version: 1,
            subscribe: true,
            defaultSort: { 'content.name': 'asc' },
            defaultOptions: { size: 100 }
        },
        house: {
            version: 1,
            subscribe: true,
            references: ['complex'],
            defaultSort: { 'content.name': 'asc' },
            defaultOptions: { size: 100 }
        },
    ]
    ```
* Принцип работы. Каждый раз когда исползуется UseData, запускаются два сценария:
    * Запрашиваемый класс переберает все классы, проверяя есть ли они в references. Если есть, ищет совпадающие объекты каждого класса из references и вставляет их.
    * Запрашиваемый класс смотрит свои references, ищет совпадающие объекты для каждого и добавляет их.
* Таким образом, не важно какой класс загрузится первым, один из сценариев вставит объекты по связям. Например, если в примере выше complex загрузится первым, то связи проставятся, когда загрузится house, т.к. прописано references: ['complex'], т.е. первый сценарий. Если же house загрзуится первым, то связи проставятся, когда загрузится complex, т.к. он переберет все классы и найдет себя в references в классе house.
#### UseData
* Добавлен статус loading. Он есть у самой UseData и у объекта Noodl, в который UseData записывает данные.
* Поправлен баг, из-за которого не обновлялись данные при subcribe: true
* Убрана опция Set references
#### UseSearch v0.2.0
* За счет нового подхода к связям теперь проделывает такую работу с найденными данными:
    * Заменяет найденные объекты объектами Noodl, тем самым восстанавливая связи.
    * В соответсвии с параметром Database classes, добавляет в реузльтааты поиска свзязанные данные.
#### Шаблоны Mustache
* Добавлена возможность экранировать спец. символы. Если в выводимых данных есть кавычки или другие символы, нужно использовать тройные скобки: '{{{content.name}}}'. Это работает для таблицы и всех компонентов-инпутов, у которых есть поле "Label field".
#### Select v0.3.0
* Устаканился принцип работы. Этот же принцип постепенно будет использоовать в дргих компонентах такого типа. Теперь он может обрабатывать 2 типа данных: Items и Custom items. Items основной, здесь нужно использовать стандартный формат данных любого класса. Нужно просто подать массив данных, Select сам конвертирует в нужный формат. Второй тип данных ручной: Custom items. Его нужно использовать, когда данные для выбора требуется создать на месте, а не брать с базы. Формат должен быть такой:
    ```
    [
        {
            value: 'option1',
            label: 'Вариант 1'
        },
        {
            value: 'option2',
            label: 'Вариант 2'
        },    
    ]
    ```

## 2023-07-28 v0.1.2
### Общие изменения:
* Миша обнаружил проблему, некоторые ноды выдают ошибку, если какой то обязательный параметр пуст. Все ноды теперь обернуты в специальный wrapper, который берет параметр portsToCheck и проверяет заполнены ли эти параметры, если не заполненны прямо на старннице где раполоагется нода будет выдано предупреждение. Если вы увидели какую то ноду, которая выдает ошибку на какой то пустой параметр, сообщайте, буду добавлять проверку или дефолтное значение.
* Принял решение изменить название переменной класса БД. Была 'className', стала 'dbClass'. Слишком много пересченией с другими класами: клсаа js, класс css...
### Новые молекулы:
* Box. Box - единственная молекула, которая не имеет праметров в Mantine. Она принимает только sx. Для этого и создана - прикручивать любой css. Очень похожа на Group в Noodl. В нашем случае добавлены параметры высоты, ширины и автовысоты. Эта нода появилась из-за потребности упралять скролом, когда скрол всей странницы не подходит. Чтобы скрол заработал, нужно, чтобы дочерние ноды поддерживали скрол или нужно обернуть дочерние ноды Box в ScrollArea. Сейчас проверено на Table v0.2.0 Как использовать: нужно включить параметра Autoheigth и указать Bottom offset. Работает так: Box берет высоту экрана (portview), отнимает Bottom offset и задает фиксированную высоту, что и является требованием для включения скрола.
* Table v0.2.0:
    * Добавлена опция 'respectLineBreak' в схему таблицы. Эта опция нужна, если требуется сохранить переносы строк исходного текста. Пример использования:
        ```
        [
            {
                accessor: 'content.name',
                title: 'Название',
                width: '8rem',
            },
            {
                accessor: 'content.description',
                title: 'Описание',
                width: '8rem',
                props: {
                    respectLineBreak: true
                }
            }
        ]
        ```
    * Добавлена возможность использовать шаблоны доступа к данным поля. Для этого используется библиоткека Mustache. Пример использования:
        ```
        [{
            accessor: 'Уважаемый {{content.firstName}} {{content.lastName}}, еще текст...',
            title: 'ФИО',
            width: '8rem',
        }]    
        ```
    * Добавлена проверка, что схема таблицы не пуста.
    * Теперь таблица не ждет структуры данных, для которой нужно указывать класс БД. В нее нужно подавать массив объектов.
* UseData v0.2.0 Добавлена проверка, что класс БД указан.