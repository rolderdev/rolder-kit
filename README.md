# Rolder Kit

## Это такой кит, большой и красивый.

[Документация и changelog](https://docs.rolder.app)

## Интеграция нод в Roodl

### Памятка по разработке нод

#### Декларация

Декларация - это схема, определяющая базовые праметры, задающая входные/выходные порты ноды и их поведение. Для каждой версии ноды своя декларация.

Нода создается нашими функциями - `jsNode` и `reactNode`. Они принимают три параметра:

- Название ноды. Для js-нод c маленькой буквы, для react-нод с большой. Под капотом функция добавит в системное название `rolder-kit.${nodeName}`, отличив наши ноды от всех других. Отображаемое название будет равняться заданному.
- Декларации версий. Это объект, где ключ - версия без хештега, значение - сама декларация.
- Параметры. Это объект. Он один на все версии. Т.е. мы не моем менять их для каждой версии отдельно. Параметры, все опциональны:

  - `color`. Цвет ноды. TS предложит варианты. Общая логика такая. Визуальная нода - синий, работа с бекенд или интеграциями - зеленый, все остальное - фиолетовый. Серый не используем, чтобы разработчик легко отличал свои повторяемые функции от RK. Если не установить цвет, js-нода будет зеленой, а react-нода синей.
  - `docs`. Ссылка на документацию. Если ссылка есть, в панели параметров рядом с переименованием и удалением появится вопросик для перехода. Документация не отображается в браузере компонентов Roodl.

Декларация версии:

- `hashTag`. Добавляет к отображаемой версии ноды выбранный хеш-тег.
- `module`. Единственный обязятельный параметр.
  - `static`. В теле до экспорта нужно добавить импорт текущей версии и добавить название импорта в значение ключа `static`. Такой вид импорта не выделяет код в отдельный файл и он будет загружаться вместе с приложением не зависимо от того используется нода или нет.
  - `dynamic`. В ключ нужно передать динамичный импорт - `module: { dynamic: import('@packages/search-v0.1.0') }`. Такой вид импорт выделит код в отдельный файл и он будет загружаться в момент первого использования ноды.
- `inputs`. У инпутов больше всего параметров и больше всего обработки. На уровне декларации инпут - это тоже декларация, т.е. это форма удобная для описания декларации и внутреннего применения в `jsNode` и `reactNode`. Под капотом они преобразуются в нужную `Roodl` форму в стандартизованном виде. Задается массивом, в котором каждый инпут нужно получать через функцию-парсер декларации - `getPortDef`. Эта функция подскажет, что можно делать, а что нельзя. Порядок в массиве имеет значение, ровно как задан, так и будет отображен в редакторе. Больше нет возможности задавать инпуты по шаблонам кучей. Это сделано во избежании лишнего кода в каждой ноде. Есть два стандартных порта, которые автоматически добавляются в массив: `version` - порт с выбором версии, всегда первый и `customProps` - функция, которая возвращает любые кастомные настройки разработчка в `Roodl`, которые может использовать разработчик ноды, всегда последний. Декларация инпута, которую нужно подавать в `getPortDef` (все параметры обязательны, кроме специально отмеченных):
  - `name`. Название инпута. Будет переданно в функцию разрабатываемого модуля через `props` с таким же названием.
  - `displayName`. Отображаемое имя для разработчика. Пишем с большой буквы предложением, пример - `Custom props`.
  - `group`. Название группы. Выбор из списка, т.е. названия стандартизованы, но можно выбрать `Custom`, тогда в параметры ниже можно указать любое название.
  - `customGroup`. Опционально. Название кастомной группы, если выше выбран `Custom`.
  - `type`. Тип инпута. На типах много завязано. Происходит несколько проверок, часть встроенные, часть разработчик может задать сам. Любые проверки выдают ошибки при их не прохождении. В отличии от предыдущей версии, больше не нужно перезагружать приложение, чтобы сбросить ошибку, достаточно подать новое корректное значение. Подробнее:
    - Литералы - `string`, `number` и `boolean`. Простые типы, не конвертируются, проверяются на соответсвие. При не соответствии типа разработчику будет показана соотвествующая ошибка.
    - `signal`. Сигнал. Не проходит проверок. Сигнал - это простой тогл true/false. Когда сигнал подан - true и тут же false. Под капотом мы реагируем на true.
    - `object`. Объект. Можно подавать только через подключение, в редакторе не доступен. Проверяется на то, что он объект.
    - `array`. Массив. Если подан через подключение, проверяеться, что массив. Если через редактор, то это текст, т.к. параметры редактора сохраняются в `project.json`, а массив может содержать функции. Преобразуется в массив с отлавливанием ошибок синтаксиса.
    - `proplist`. Список текстовых праметров. Задается только через редактор. Под капотом - это массив текстов. Не проверяется.
    - `component`. Путь к шаблонку компоненты. Обычный тектс, не проверяется.
    - `objectEval`. Наш специальный тип. Это функция, которая принимает текущие `props` и должна вернуть объект. Под капотом в `Roodl` подается как тип `array`, благодаря чему разработчик может устанавливать значение в редакторе, причем не как массив, а сразу функцией. Как и массив, `Roodl` сохранит функцию текстом. Преобразуется в функцию. Проверяется, что это функция, что нет синтаксических ошибок и что возвращаемое значение объект.
    - `funcEval`. Наш специальный тип. Так же как `objectEval`, но ничего не возвращает.
  - `default`. Опционально. Дефолтное значение. Можно устанавливать только для простых типов.
  - `codeComment`. Опционально. Для типов `array`, `objectEval` и `funcEval` можно указать комментарий. Такой комментарий будет виден в редакторе, но будет удален при конвертации. Хороший пример - указать закомментированный пример схемы, массива или функции. Тогда разработчику остается убрать скобки комментариев и код готов.
  - `visibleAt`. Опционально. Видиость порта: `editor` - только в редакторе, `connection` - только через подключение, `both` - оба. Если не указать будет `both`.
  - `tooltip`. Опционально. Подсказка. Подается в виде текста, который может содержать стандартные `HTML`-теги. Учти, текст изначально жирный. Пробовал выделять тектс косым, вставлять картинки, делать списки. Все работает.
  - `dependsOn`. Опционально. Функция, делающая инпут зависимым. Принимает текущие `props`, должна вернуть `true/false`. При положительном возврате порт будет добавлен, иначе нет. Запускается после конвертации значений и присвоения дефолтов, что дает актуальные `props`.
  - `validate`. Опционально. Функция для проверки значения. Заменяет устаревший параметр `required`. Принимает текущие `props`. Нужно веруть `true` - валидация прошла успешно, `false` - валидация не прошла, разработчику будет показано сообщение `Input "${inputDef.displayName}" is required.`, `string` - валидация не прошла, разработчику будет показано твое сообщение.
  - `transform`. Опционально. Функция преобразования порта. Преобразует изначальную декларацию в новую. Пример - когда тип указан списком и состав списка нужно менять в зависимости от значения других параметров. Принимает текущие `props` и текущую декларацию инпута. Нужно вернуть новую декларацию инпута. Если в новой декларации будет задан `default`, он будет сконвертирван, если нужно и проверен на тип.
- `outputs`. Задаются как `inputs`, поддерживая все параметры. Логично, что не все типы (кастомные и те, что имеют смысл только в редакторе) имеют смысл, нет смысла делать валидацию (это задача разработчика ноды), нет смысла в дефолте и подсказке. Но часто нужно указать `dependsOn`, изредка `transform`. Значения никак не конверируются или проверяются.
- `triggerOnInputs`. Функция, указывающая список инпутов, на подачу которых нужно запускать реактивную js-функцию. Принимает текущие `props`, нужно вернуть список с названиями портов. Список не проверяется. Подробнее зачем это нужно ниже.
- `getInspectInfo`. Функция для отображения полезной информации над нодой. Принимает текущие `props` и значения выходных портов. Нужно вернуть массив, в котором объекты - это раздел с отображаемой информацией. Вот пример, где первая строка простой текст, имитирующий заголовок, воторая массив:
- `disableCustomProps`: Параметр отключения встроенного инпута `customProps`.

```ts
getInspectInfo(p, outProps) {
	if (p.fields)
		return [
			{ type: 'text', value: 'Search fields' },
			{ type: 'value', value: p.fields },
		];
	else return [];
},
```

- `transform`. Функция преобразования всех портов. Работает как `transform` для одного порта, но на вход получает все порты в объекте, с разделением на `inputs` и `outputs`. Вернуть нужно объект с портами в таком же формате.

#### JS-нода

Если React-нода - это одна React-компонента, то JS-нода - это объект с одной или несколькими функциями ключами.

##### Требования

- Должен быть дефолтный экспорт.
- Название ключей должны совпадать с названием входных сигналов или называться `reactive`. Функции не должны что-то возвращать.
- В делкарации должен быть объявлен соотвествующий порт-сигнал и/или `triggerOnInputs`, выдающий список портов, на подачу которых будет запускаться `reactive`.
- Функции могут быть асинхронными, но нужно учитывать, что пока не завершилась асинхронная функция, повторный запуск этой или других функций не возможен. При этом значения портов сохраняется в любой момент.

##### Варианты использования

Раз JS-нода это объект с функциями, то можно передать его в константу и экспортировать эту константу. Тогда внтури функций объекта можно запускать другие функции этого же объекта. Такой подходи называют `Фабрикой`.

- Классический вариант. Название функций должно совпадать с названиями сигналов. Сигнал будет просто запускать такую функцию. Функции `reactive` не должно быть. `triggerOnInputs` должен отсутстовавть.
- Реактивный вариант. Функция должна называться `reactive`, сигналов не должно быть. В декларации ноды `triggerOnInputs` должен вернуть список инпутов. Сама `triggerOnInputs` принимает текущие `props`. Функция запустится всякий раз при обновлении значений ипутов из списка.
- Комбинированный вариант. Повторяем первые два. Имеет смысл в сценариях, когда основное поведение задано через реактивную функцию, а сигналы служат для каких-то отдельных задач. Редкая история, чаще всего хватает первых двух. Что точно не верно - это пытаться делать одно и тоже и через сигнал и реактивно.

##### Примеры

Классический или сигналы.

```ts
export default {
	sendData: (p: Props) => {
		// Какой то код
	},
	setServerState: (p: Props) => {
		// Какой то код
	},
};
```

Реактивный вариант.

```ts
export default {
	reactive: (p: Props) => {
		// Какой то код
	},
};
```

Комбинированный вариант.

```ts
export default {
	reactive: (p: Props) => {
		// Какой то код
	},
	sendData: (p: Props) => {
		// Какой то код
	},
};
```

Фабрика.

```ts
const myFabric = {
	reactive: (p: Props) => {
		// Какой то код
	},
	sendData: async (p: Props) => {
		// Какой то код
	},
	someExtraUsefulFunc: async (p: Props) => {
		const result = await myFabric.sendData({ ...p, someNewProp: 'value' });
		if (result) doSome;
	},
};
export default myFabric;
```
